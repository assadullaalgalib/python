# -*- coding: utf-8 -*-
"""UGS .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1B2jL0gV9xVB_3rfmuvPdY3mKNKjb6G0r

Implement the Uniform Cost Search (UCS) algorithm to find the least-cost path in a weighted graph. The graph is represented as a dictionary where each key is a node, and the value is a list of tuples representing neighboring nodes and their respective edge weights.
"""

import heapq

def uniform_cost_search(start_node, stop_node):
    # Priority queue to explore nodes with the lowest cost first
    open_set = []
    heapq.heappush(open_set, (0, start_node))
    closed_set = set()
    g = {}  # Cost from start_node to the current node
    parents = {}  # To reconstruct the path

    # Initialize the cost of the start node
    g[start_node] = 0
    parents[start_node] = start_node

    while open_set:
        current_cost, n = heapq.heappop(open_set)

        if n == stop_node:
            # Reconstruct the path from stop_node to start_node
            path = []
            while parents[n] != n:
                path.append(n)
                n = parents[n]
            path.append(start_node)
            path.reverse()
            print('Path found: {}'.format(path))
            return path

        closed_set.add(n)

        for (m, weight) in get_neighbors(n):
            if m in closed_set:
                continue

            new_cost = g[n] + weight

            if m not in g or new_cost < g[m]:
                g[m] = new_cost
                parents[m] = n
                heapq.heappush(open_set, (new_cost, m))

    print('Path does not exist!')
    return None

# Define function to return neighbors and their distances
def get_neighbors(v):
    return Graph_nodes.get(v, [])

# Graph definition
Graph_nodes = {
    'A': [('B', 2), ('E', 3)],
    'B': [('A', 2), ('C', 1), ('G', 9)],
    'C': [('B', 1)],
    'D': [('E', 6), ('G', 1)],
    'E': [('A', 3), ('D', 6)],
    'G': [('B', 9), ('D', 1)]
}

uniform_cost_search('A', 'G')